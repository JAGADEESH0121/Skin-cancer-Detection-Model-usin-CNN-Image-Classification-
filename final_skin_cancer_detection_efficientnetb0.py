# -*- coding: utf-8 -*-
"""Final_skin_cancer_detection_EfficientNetB0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-eu47pYiAOcTn7dRCggHHxJexW2HPOab
"""

import os, glob
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.callbacks import Callback, EarlyStopping
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.applications.resnet50 import preprocess_input
from sklearn.metrics import classification_report

!pip install kaggle

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d "hasnainjaved/melanoma-skin-cancer-dataset-of-10000-images"

import zipfile
import os

# Define paths
zip_path = "/content/melanoma-skin-cancer-dataset-of-10000-images.zip"  # Adjust if filename is different
extract_path = "/content/skin_cancer_dataset"

# Create directory if not exists
os.makedirs(extract_path, exist_ok=True)

# Extract with progress bar
print("Extracting dataset...")
with zipfile.ZipFile(zip_path, "r") as zip_ref:
    zip_ref.extractall(extract_path)

print("Dataset extracted successfully to:", extract_path)

import os

dataset_path = "/content/skin_cancer_dataset"  # Update if needed

# Walk through and display only directories
print("üìÅ All Folders in Dataset:\n")
for root, dirs, files in os.walk(dataset_path):
    for dir_name in dirs:
        print(os.path.join(root, dir_name))

file_path="/content/skin_cancer_dataset/melanoma_cancer_dataset/train"

name_class=os.listdir(file_path)
name_class

filepaths = list(glob.glob(file_path+'/**/*.*'))
filepaths

labels = list(map(lambda x: os.path.split(os.path.split(x)[0])[1], filepaths))
labels

filepath = pd.Series(filepaths, name='Filepath').astype(str)
labels = pd.Series(labels, name='Label')
data = pd.concat([filepath, labels], axis=1)
data = data.sample(frac=1).reset_index(drop=True)
data.head(5)

counts = data.Label.value_counts()
sns.barplot(x=counts.index, y=counts)
plt.xlabel('Type')
plt.xticks(rotation=90);

train, test = train_test_split(data, test_size=0.25, random_state=42)

fig, axes = plt.subplots(nrows=5, ncols=3, figsize=(10,8), subplot_kw={'xticks':[],'yticks':[]})
for i, ax in enumerate(axes.flat):
    ax.imshow(plt.imread(data.Filepath[i]))
    ax.set_title(data.Label[i])
plt.tight_layout()
plt.show()

# Step 17: Loading a Pretrained EfficientNetB0 Model
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.applications.efficientnet import preprocess_input

pretrained_model = EfficientNetB0(
    input_shape=(224,224, 3),  # Keeping the same input size
    include_top=False,
    weights='imagenet',
    pooling='avg'
)

pretrained_model.trainable = False

# Step 18: Adding Custom Layers on Top of EfficientNetB0
inputs = pretrained_model.input

x = Dense(128, activation='relu')(pretrained_model.output)
x = Dense(128, activation='relu')(x)

outputs = Dense(2, activation='softmax')(x)

model = Model(inputs=inputs, outputs=outputs)

# Step 19: Compiling the Model
model.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

# Step 20: Updating Preprocessing for EfficientNetB0
train_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)
test_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)

train_gen = train_datagen.flow_from_dataframe(
    dataframe=train,
    x_col='Filepath',
    y_col='Label',
    target_size=(224,224),
    class_mode='categorical',
    batch_size=32,
    shuffle=True,
    seed=42
)
valid_gen = train_datagen.flow_from_dataframe(
    dataframe=test,
    x_col='Filepath',
    y_col='Label',
    target_size=(224,224),
    class_mode='categorical',
    batch_size=32,
    shuffle=False,
    seed=42
)
test_gen = test_datagen.flow_from_dataframe(
    dataframe=test,
    x_col='Filepath',
    y_col='Label',
    target_size=(224,224),
    class_mode='categorical',
    batch_size=32,
    shuffle=False
)

my_callbacks  = [EarlyStopping(monitor='val_accuracy',
                              min_delta=0,
                              patience=2,
                              mode='auto')]

history = model.fit(
    train_gen,
    validation_data=valid_gen,
    epochs=50
)

model.save("model_skin_cancer.h5")

import pandas as pd
import matplotlib.pyplot as plt

# Convert history to DataFrame
history_df = pd.DataFrame(history.history)

# Apply a rolling average with a window size of 5 (adjust as needed)
smooth_window = 5
history_df_smooth = history_df.rolling(window=smooth_window, min_periods=1).mean()

# Plot smoothed accuracy
plt.figure(figsize=(8, 5))
history_df_smooth[['accuracy', 'val_accuracy']].plot()
plt.ylim(0.5, 1)
plt.title("Training Accuracy")
plt.xlabel("Epochs")
plt.ylabel("Accuracy")
plt.grid(True)
plt.show()

# Plot smoothed loss
plt.figure(figsize=(8, 5))
history_df_smooth[['loss', 'val_loss']].plot()
plt.ylim(0, 1.5)
plt.title("Training Loss")
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.grid(True)
plt.show()

results = model.evaluate(test_gen, verbose=0)

print("    Test Loss: {:.5f}".format(results[0]))
print("Test Accuracy: {:.2f}%".format(results[1] * 100))

# Predict the label of the test_gen
pred = model.predict(test_gen)
pred = np.argmax(pred,axis=1)

# Map the label
labels = (train_gen.class_indices)
labels = dict((v,k) for k,v in labels.items())
pred = [labels[k] for k in pred]

y_test = list(test.Label)
print(classification_report(y_test, pred))

fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 8),
                        subplot_kw={'xticks': [], 'yticks': []})

for i, ax in enumerate(axes.flat):
    ax.imshow(plt.imread(test.Filepath.iloc[i]))
    ax.set_title(f"True: {test.Label.iloc[i]}\nPredicted: {pred[i]}")
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# Get true labels from test_gen
y_true = test_gen.classes  # Assuming test_gen is an ImageDataGenerator

# Get predicted labels
y_pred = model.predict(test_gen)
y_pred = np.argmax(y_pred, axis=1)  # Convert probabilities to class indices

# Compute confusion matrix
cm = confusion_matrix(y_true, y_pred)

# Plot the confusion matrix
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap="Blues", xticklabels=test_gen.class_indices.keys(), yticklabels=test_gen.class_indices.keys())
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix")
plt.show()

from tensorflow.keras.models import load_model
loaded_model_skin_cancer = load_model("/content/model_skin_cancer.h5")
from tensorflow.keras.applications.resnet50 import preprocess_input, decode_predictions

import cv2
import numpy as np
from matplotlib.pyplot import imread
from matplotlib.pyplot import imshow
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.imagenet_utils import decode_predictions
from tensorflow.keras.applications.imagenet_utils import preprocess_input

img_path = '/content/skin_cancer_dataset/melanoma_cancer_dataset/test/malignant/melanoma_10345.jpg'
#img = image.load_img(img_path, target_size=(224, 224))
#x = img.img_to_array(img)

img = cv2.imread(img_path)
img = cv2.resize(img, (224, 224))

x = np.expand_dims(img, axis=0)
x = preprocess_input(x)
result = loaded_model_skin_cancer.predict(x)
print((result*100).astype('int'))

#print('Input image shape:', x.shape)

#my_image = imread(img_path)
#imshow(my_image)
plt.imshow(img)

p=list((result*100).astype('int'))
pp=list(p[0])
print(pp)

print("Largest element is:", max(pp))

index = pp.index(max(pp))

name_class=['benign', 'Malignant']

name_class[index]

import os, glob
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.callbacks import Callback, EarlyStopping
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.applications.resnet50 import preprocess_input
from sklearn.metrics import classification_report, roc_curve, auc

# Model evaluation
results = model.evaluate(test_gen, verbose=0)
print("    Test Loss: {:.5f}".format(results[0]))
print("Test Accuracy: {:.2f}%".format(results[1] * 100))

# Compute predictions and probabilities
y_test = list(test.Label)
y_prob = model.predict(test_gen)

# Convert labels to binary (0 and 1)
label_mapping = {'benign': 0, 'malignant': 1}
y_test_binary = np.array([label_mapping[label] for label in y_test])

# Compute ROC curve
fpr, tpr, _ = roc_curve(y_test_binary, y_prob[:, 1])
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc='lower right')
plt.show()

# Classification report
print(classification_report(y_test_binary, np.argmax(y_prob, axis=1)))